use std::error::Error;
use std::fmt::{Display, Formatter};
use urid::{Uri, URID};

/// A Helper struct to store data about a type for alignment error messages
#[derive(Debug, Clone, Eq, PartialEq)]
pub(crate) struct TypeData {
    name: &'static str,
    size: usize,
    align: usize,
}

impl TypeData {
    pub(crate) fn of<T: 'static>() -> Self {
        Self {
            name: core::any::type_name::<T>(),
            size: core::mem::size_of::<T>(),
            align: core::mem::align_of::<T>(),
        }
    }
}

impl Display for TypeData {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{} (size: {}, align: {})",
            self.name, self.size, self.align
        )
    }
}

/// The actual, currently private, alignment error
#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub(crate) enum AlignmentErrorInner {
    CannotComputeAlignment {
        type_id: TypeData,
        ptr: *const u8,
    },
    UnalignedBuffer {
        type_id: TypeData,
        ptr: *const u8,
    },
    NotEnoughSpaceToRealign {
        type_id: TypeData,
        ptr: *const u8,
        required_padding: usize,
        available_size: usize,
    },
}

/// An alignment error, returned by [`AlignedSpace`].
///
/// This error occurs when a byte buffer is unaligned, or could not be aligned.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AlignmentError(pub(crate) AlignmentErrorInner);

impl From<AlignmentError> for AtomWriteError {
    #[inline]
    fn from(error: AlignmentError) -> Self {
        AtomWriteError::AlignmentError(error)
    }
}

impl From<AlignmentError> for AtomReadError {
    #[inline]
    fn from(error: AlignmentError) -> Self {
        AtomReadError::AlignmentError(error)
    }
}

impl Display for AlignmentError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match &self.0 {
            AlignmentErrorInner::CannotComputeAlignment { type_id, ptr } => {
                write!(f, "Could not compute alignment for pointer {:?} while trying to align it for type {}", ptr, type_id)
            }
            AlignmentErrorInner::UnalignedBuffer { type_id, ptr } => {
                write!(
                    f,
                    "Pointer {:?} is not properly aligned for type {}",
                    ptr, type_id
                )
            }
            AlignmentErrorInner::NotEnoughSpaceToRealign {
                type_id,
                ptr,
                required_padding,
                available_size,
            } => {
                write!(f, "Not enough space to realign pointer {:?} for type {} (needs {} padding bytes, but only {} bytes are available)",
                ptr, type_id, required_padding, available_size)
            }
        }
    }
}

impl Error for AlignmentError {}

/// Errors that can occur while writing atoms to a byte buffer.
#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub enum AtomWriteError {
    /// A write operation could not proceed because there is not enough space in the allocatable buffer.
    OutOfSpace {
        /// The amount currently used in the buffer, in bytes.
        used: usize,
        /// The total capacity of the buffer, in bytes.
        capacity: usize,
        /// The requested amount of bytes to be allocated in the buffer, in bytes.
        ///
        /// If this error occurred, most likely this is higher than the remaining amount of bytes available.
        requested: usize,
    },
    /// An allocator tried to be rewound beyond the amount of already allocated bytes
    RewindBeyondAllocated {
        /// The amount of already allocated bytes
        allocated: usize,
        /// The amount of bytes requested to be rewound
        ///
        /// If this error occurred, most likely this is higher than the amount of allocated bytes
        requested: usize,
    },
    /// A write operation tried to occur outside of the buffer's bounds
    WritingOutOfBounds {
        /// The amount of available bytes in the buffer
        available: usize,
        /// The requested amount of bytes
        requested: usize,
    },
    /// An error generated by a given atom type while writing
    IllegalOperation {
        /// The type URI of the atom that raised the error
        writing_type_uri: &'static Uri,
        /// An user-friendly error message
        error_message: &'static str,
    },
    AlignmentError(AlignmentError),
}

impl Display for AtomWriteError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            AtomWriteError::OutOfSpace {
                used,
                capacity,
                requested,
            } => {
                write!(f, "Failed to allocate {} bytes: buffer is too small (used: {} / {} bytes, remaining: {} bytes",
                requested, used, capacity, capacity - used)
            }
            AtomWriteError::RewindBeyondAllocated {
                allocated,
                requested,
            } => {
                write!(f, "Attempted to rewind {} bytes before the start of buffer (buffer position: {}, requested a rewind of {} bytes",
                requested - allocated, allocated, requested)
            }
            AtomWriteError::WritingOutOfBounds {
                requested,
                available,
            } => {
                write!(f, "Attempted to write {} bytes past the end of buffer (buffer size: {}, requested write of {} bytes",
                requested - available, available, requested)
            }
            AtomWriteError::IllegalOperation {
                writing_type_uri,
                error_message,
            } => {
                write!(
                    f,
                    "Illegal operation when trying to write Atom of type {}: {}",
                    writing_type_uri.to_string_lossy(),
                    error_message
                )
            }
            AtomWriteError::AlignmentError(e) => Display::fmt(e, f),
        }
    }
}

impl Error for AtomWriteError {}

#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub enum AtomReadError {
    AtomUridMismatch {
        expected_uri: &'static Uri,
        expected_urid: URID,
        found_urid: URID,
    },
    InvalidUrid {
        expected_uri: &'static Uri,
        expected_urid: URID,
        found_urid: u32,
    },
    ReadingOutOfBounds {
        available: usize,
        requested: usize,
    },
    InvalidAtomValue {
        reading_type_uri: &'static Uri,
        error_message: &'static str,
    },
    AlignmentError(AlignmentError),
}

impl Display for AtomReadError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            AtomReadError::AtomUridMismatch {
                expected_uri,
                expected_urid,
                found_urid,
            } => {
                write!(
                    f,
                    "Mismatched Atom URID for Type '{}': Expected URID #{}, found #{}",
                    expected_uri.to_string_lossy(),
                    expected_urid.get(),
                    found_urid.get()
                )
            }
            AtomReadError::InvalidUrid {
                expected_uri,
                expected_urid,
                found_urid,
            } => {
                write!(f, "Found invalid URID value ({}) while trying to read Atom URID Type {} (URID #{})",
                          found_urid, expected_uri.to_string_lossy(), expected_urid.get())
            }
            AtomReadError::ReadingOutOfBounds {
                available,
                requested,
            } => {
                write!(f, "Attempted to read {} bytes past the end of buffer (buffer size: {}, requested write of {} bytes",
                       requested - available, available, requested)
            }
            AtomReadError::InvalidAtomValue {
                reading_type_uri,
                error_message,
            } => {
                write!(
                    f,
                    "Invalid Atom value for type {}: {}",
                    reading_type_uri.to_string_lossy(),
                    error_message
                )
            }
            AtomReadError::AlignmentError(e) => Display::fmt(e, f),
        }
    }
}

impl Error for AtomReadError {}

#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AtomError {
    ReadError(AtomReadError),
    WriteError(AtomWriteError),
}

impl Display for AtomError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            AtomError::ReadError(e) => write!(f, "Could not read atom data: {}", e),
            AtomError::WriteError(e) => write!(f, "Could not write atom data: {}", e),
        }
    }
}

impl Error for AtomError {}

impl From<AtomReadError> for AtomError {
    #[inline]
    fn from(error: AtomReadError) -> Self {
        AtomError::ReadError(error)
    }
}

impl From<AtomWriteError> for AtomError {
    #[inline]
    fn from(error: AtomWriteError) -> Self {
        AtomError::WriteError(error)
    }
}
