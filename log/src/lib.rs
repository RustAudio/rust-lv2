use lv2_core::feature::*;
//use std::ffi::CString;
use std::fmt;
use std::os::raw::*; //get all common c_type
use urid::*;

pub struct EntryClass;
unsafe impl UriBound for EntryClass {
    const URI: &'static [u8] = lv2_sys::LV2_LOG__Entry;
}

/// UriBound for an error message.
pub struct ErrorClass;
unsafe impl UriBound for ErrorClass {
    const URI: &'static [u8] = lv2_sys::LV2_LOG__Error;
}

/// UriBound for an informative message.
pub struct NoteClass;
unsafe impl UriBound for NoteClass {
    const URI: &'static [u8] = lv2_sys::LV2_LOG__Note;
}

/// UriBound for a debuging message.
pub struct TraceClass;
unsafe impl UriBound for TraceClass {
    const URI: &'static [u8] = lv2_sys::LV2_LOG__Trace;
}

/// Uribound for an error message.
pub struct WarningClass;
unsafe impl UriBound for WarningClass {
    const URI: &'static [u8] = lv2_sys::LV2_LOG__Warning;
}

/// Marker for URID representing the nature of a log message.
// Note : it's may be better to have a URID trait to define a common interface
pub unsafe trait EntryType
where
    Self: Copy,
{
    fn get(self) -> u32;
}

unsafe impl EntryType for URID<ErrorClass> {
    fn get(self) -> u32 {
        URID::<ErrorClass>::get(self)
    }
}
unsafe impl EntryType for URID<NoteClass> {
    fn get(self) -> u32 {
        URID::<NoteClass>::get(self)
    }
}
unsafe impl EntryType for URID<TraceClass> {
    fn get(self) -> u32 {
        URID::<TraceClass>::get(self)
    }
}
unsafe impl EntryType for URID<WarningClass> {
    fn get(self) -> u32 {
        URID::<WarningClass>::get(self)
    }
}

/// Errors potentially generated by [`Log`](struct.Log.html) methods.
#[derive(PartialEq, Eq, Clone, Copy, Debug)]
pub enum LogError {
    /// An error occured when sending message to the host
    PrintError,
    /// The provided string don't have a `'\0'` to indicate it's end
    NoNullTerminator,
    /// No callback was provided by the host
    ///
    /// This can only happen with a faulty host
    NoCallback,
}

/// The Log feature.
#[repr(transparent)]
pub struct Log<'a> {
    internal: &'a lv2_sys::LV2_Log_Log,
}

unsafe impl<'a> UriBound for Log<'a> {
    const URI: &'static [u8] = lv2_sys::LV2_LOG__log;
}

unsafe impl<'a> Feature for Log<'a> {
    // Note: this feature can be used in any threading class and doesn't seems to have thready
    // unsafty, but you are supposed to only use the trace log in rt context
    unsafe fn from_feature_ptr(feature: *const c_void, _class: ThreadingClass) -> Option<Self> {
        (feature as *const lv2_sys::LV2_Log_Log)
            .as_ref()
            .map(|internal| Self { internal })
    }
}

impl<'a> Log<'a> {
    /// Send a log message to the host.
    ///
    /// the `entry_type` parameter is an URID representing the kind of log message. There are four
    /// kind of message:
    /// * **note:** an informative message.
    /// * **warning:** a warning message.
    /// * **error:** an error message.
    /// * **trace:** a debugging trace. These entries should not be displayed during normal
    /// operation, but the host may implement an option to display them for debugging purposes.
    /// This entry type is special in that it may be written to in a real-time thread. It is
    /// assumed that if debug tracing is enabled, real-time considerations are not a concern.
    pub fn print(&self, entry_type: impl EntryType, message: &str) -> Result<(), LogError> {
        let printf = if let Some(printf) = self.internal.printf {
            printf
        } else {
            return Err(LogError::NoCallback);
        };
        //checking for null terminator
        let mut have_null = false;
        for b in message.bytes() {
            if b == b'\0' {
                have_null = true;
                break;
            }
        }
        if !have_null {
            return Err(LogError::NoNullTerminator);
        }

        let res = unsafe {
            (printf)(
                self.internal.handle,
                entry_type.get(),
                "%s\0" as *const _ as *const c_char,
                message as *const _ as *const c_char,
            )
        };
        if res > 0 {
            Ok(())
        } else {
            Err(LogError::PrintError)
        }
    }
}

/// A URID cache containing all log properties.
#[derive(URIDCollection, Debug)]
pub struct LogURIDCollection {
    pub entry_class: URID<EntryClass>,
    pub error_class: URID<ErrorClass>,
    pub note_class: URID<NoteClass>,
    pub trace_class: URID<TraceClass>,
    pub warning_class: URID<WarningClass>,
    //pub log: URID<Log<'a>>,
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
