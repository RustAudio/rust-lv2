/* automatically generated by rust-bindgen */

pub const LV2_CORE_URI: &[u8; 29usize] = b"http://lv2plug.in/ns/lv2core\0";
pub const LV2_CORE_PREFIX: &[u8; 30usize] = b"http://lv2plug.in/ns/lv2core#\0";
pub const LV2_CORE__AllpassPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#AllpassPlugin\0";
pub const LV2_CORE__AmplifierPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#AmplifierPlugin\0";
pub const LV2_CORE__AnalyserPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#AnalyserPlugin\0";
pub const LV2_CORE__AudioPort: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#AudioPort\0";
pub const LV2_CORE__BandpassPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#BandpassPlugin\0";
pub const LV2_CORE__CVPort: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#CVPort\0";
pub const LV2_CORE__ChorusPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#ChorusPlugin\0";
pub const LV2_CORE__CombPlugin: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#CombPlugin\0";
pub const LV2_CORE__CompressorPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#CompressorPlugin\0";
pub const LV2_CORE__ConstantPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#ConstantPlugin\0";
pub const LV2_CORE__ControlPort: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#ControlPort\0";
pub const LV2_CORE__ConverterPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#ConverterPlugin\0";
pub const LV2_CORE__DelayPlugin: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#DelayPlugin\0";
pub const LV2_CORE__DistortionPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#DistortionPlugin\0";
pub const LV2_CORE__DynamicsPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#DynamicsPlugin\0";
pub const LV2_CORE__EQPlugin: &[u8; 38usize] = b"http://lv2plug.in/ns/lv2core#EQPlugin\0";
pub const LV2_CORE__EnvelopePlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#EnvelopePlugin\0";
pub const LV2_CORE__ExpanderPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#ExpanderPlugin\0";
pub const LV2_CORE__ExtensionData: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#ExtensionData\0";
pub const LV2_CORE__Feature: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#Feature\0";
pub const LV2_CORE__FilterPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#FilterPlugin\0";
pub const LV2_CORE__FlangerPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#FlangerPlugin\0";
pub const LV2_CORE__FunctionPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#FunctionPlugin\0";
pub const LV2_CORE__GatePlugin: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#GatePlugin\0";
pub const LV2_CORE__GeneratorPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#GeneratorPlugin\0";
pub const LV2_CORE__HighpassPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#HighpassPlugin\0";
pub const LV2_CORE__InputPort: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#InputPort\0";
pub const LV2_CORE__InstrumentPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#InstrumentPlugin\0";
pub const LV2_CORE__LimiterPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#LimiterPlugin\0";
pub const LV2_CORE__LowpassPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#LowpassPlugin\0";
pub const LV2_CORE__MixerPlugin: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#MixerPlugin\0";
pub const LV2_CORE__ModulatorPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#ModulatorPlugin\0";
pub const LV2_CORE__MultiEQPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#MultiEQPlugin\0";
pub const LV2_CORE__OscillatorPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#OscillatorPlugin\0";
pub const LV2_CORE__OutputPort: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#OutputPort\0";
pub const LV2_CORE__ParaEQPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#ParaEQPlugin\0";
pub const LV2_CORE__PhaserPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#PhaserPlugin\0";
pub const LV2_CORE__PitchPlugin: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#PitchPlugin\0";
pub const LV2_CORE__Plugin: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#Plugin\0";
pub const LV2_CORE__PluginBase: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#PluginBase\0";
pub const LV2_CORE__Point: &[u8; 35usize] = b"http://lv2plug.in/ns/lv2core#Point\0";
pub const LV2_CORE__Port: &[u8; 34usize] = b"http://lv2plug.in/ns/lv2core#Port\0";
pub const LV2_CORE__PortProperty: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#PortProperty\0";
pub const LV2_CORE__Resource: &[u8; 38usize] = b"http://lv2plug.in/ns/lv2core#Resource\0";
pub const LV2_CORE__ReverbPlugin: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#ReverbPlugin\0";
pub const LV2_CORE__ScalePoint: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#ScalePoint\0";
pub const LV2_CORE__SimulatorPlugin: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#SimulatorPlugin\0";
pub const LV2_CORE__SpatialPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#SpatialPlugin\0";
pub const LV2_CORE__Specification: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#Specification\0";
pub const LV2_CORE__SpectralPlugin: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#SpectralPlugin\0";
pub const LV2_CORE__UtilityPlugin: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#UtilityPlugin\0";
pub const LV2_CORE__WaveshaperPlugin: &[u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#WaveshaperPlugin\0";
pub const LV2_CORE__appliesTo: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#appliesTo\0";
pub const LV2_CORE__binary: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#binary\0";
pub const LV2_CORE__connectionOptional: &[u8; 48usize] =
    b"http://lv2plug.in/ns/lv2core#connectionOptional\0";
pub const LV2_CORE__control: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#control\0";
pub const LV2_CORE__default: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#default\0";
pub const LV2_CORE__designation: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#designation\0";
pub const LV2_CORE__documentation: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#documentation\0";
pub const LV2_CORE__enumeration: &[u8; 41usize] = b"http://lv2plug.in/ns/lv2core#enumeration\0";
pub const LV2_CORE__extensionData: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#extensionData\0";
pub const LV2_CORE__freeWheeling: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#freeWheeling\0";
pub const LV2_CORE__hardRTCapable: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#hardRTCapable\0";
pub const LV2_CORE__inPlaceBroken: &[u8; 43usize] = b"http://lv2plug.in/ns/lv2core#inPlaceBroken\0";
pub const LV2_CORE__index: &[u8; 35usize] = b"http://lv2plug.in/ns/lv2core#index\0";
pub const LV2_CORE__integer: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#integer\0";
pub const LV2_CORE__isLive: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#isLive\0";
pub const LV2_CORE__latency: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#latency\0";
pub const LV2_CORE__maximum: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#maximum\0";
pub const LV2_CORE__microVersion: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#microVersion\0";
pub const LV2_CORE__minimum: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#minimum\0";
pub const LV2_CORE__minorVersion: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#minorVersion\0";
pub const LV2_CORE__name: &[u8; 34usize] = b"http://lv2plug.in/ns/lv2core#name\0";
pub const LV2_CORE__optionalFeature: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#optionalFeature\0";
pub const LV2_CORE__port: &[u8; 34usize] = b"http://lv2plug.in/ns/lv2core#port\0";
pub const LV2_CORE__portProperty: &[u8; 42usize] = b"http://lv2plug.in/ns/lv2core#portProperty\0";
pub const LV2_CORE__project: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#project\0";
pub const LV2_CORE__prototype: &[u8; 39usize] = b"http://lv2plug.in/ns/lv2core#prototype\0";
pub const LV2_CORE__reportsLatency: &[u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#reportsLatency\0";
pub const LV2_CORE__requiredFeature: &[u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#requiredFeature\0";
pub const LV2_CORE__sampleRate: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#sampleRate\0";
pub const LV2_CORE__scalePoint: &[u8; 40usize] = b"http://lv2plug.in/ns/lv2core#scalePoint\0";
pub const LV2_CORE__symbol: &[u8; 36usize] = b"http://lv2plug.in/ns/lv2core#symbol\0";
pub const LV2_CORE__toggled: &[u8; 37usize] = b"http://lv2plug.in/ns/lv2core#toggled\0";
pub type __uint32_t = ::std::os::raw::c_uint;
#[doc = "Plugin Instance Handle."]
#[doc = ""]
#[doc = "This is a handle for one particular instance of a plugin.  It is valid to"]
#[doc = "compare to NULL (or 0 for C++) but otherwise the host MUST NOT attempt to"]
#[doc = "interpret it."]
pub type LV2_Handle = *mut ::std::os::raw::c_void;
#[doc = "Feature."]
#[doc = ""]
#[doc = "Features allow hosts to make additional functionality available to plugins"]
#[doc = "without requiring modification to the LV2 API.  Extensions may define new"]
#[doc = "features and specify the `URI` and `data` to be used if necessary."]
#[doc = "Some features, such as lv2:isLive, do not require the host to pass data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LV2_Feature {
    #[doc = "A globally unique, case-sensitive identifier (URI) for this feature."]
    #[doc = ""]
    #[doc = "This MUST be a valid URI string as defined by RFC 3986."]
    pub URI: *const ::std::os::raw::c_char,
    #[doc = "Pointer to arbitrary data."]
    #[doc = ""]
    #[doc = "The format of this data is defined by the extension which describes the"]
    #[doc = "feature with the given `URI`."]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__LV2_Feature() {
    assert_eq!(
        ::std::mem::size_of::<_LV2_Feature>(),
        16usize,
        concat!("Size of: ", stringify!(_LV2_Feature))
    );
    assert_eq!(
        ::std::mem::align_of::<_LV2_Feature>(),
        8usize,
        concat!("Alignment of ", stringify!(_LV2_Feature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Feature>())).URI as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Feature),
            "::",
            stringify!(URI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Feature>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Feature),
            "::",
            stringify!(data)
        )
    );
}
pub type LV2_Feature = _LV2_Feature;
#[doc = "Plugin Descriptor."]
#[doc = ""]
#[doc = "This structure provides the core functions necessary to instantiate and use"]
#[doc = "a plugin."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LV2_Descriptor {
    #[doc = "A globally unique, case-sensitive identifier for this plugin."]
    #[doc = ""]
    #[doc = "This MUST be a valid URI string as defined by RFC 3986.  All plugins with"]
    #[doc = "the same URI MUST be compatible to some degree, see"]
    #[doc = "http://lv2plug.in/ns/lv2core for details."]
    pub URI: *const ::std::os::raw::c_char,
    #[doc = "Instantiate the plugin."]
    #[doc = ""]
    #[doc = "Note that instance initialisation should generally occur in activate()"]
    #[doc = "rather than here. If a host calls instantiate(), it MUST call cleanup()"]
    #[doc = "at some point in the future."]
    #[doc = ""]
    #[doc = "@param descriptor Descriptor of the plugin to instantiate."]
    #[doc = ""]
    #[doc = "@param sample_rate Sample rate, in Hz, for the new plugin instance."]
    #[doc = ""]
    #[doc = "@param bundle_path Path to the LV2 bundle which contains this plugin"]
    #[doc = "binary. It MUST include the trailing directory separator (e.g. \'/\') so"]
    #[doc = "that simply appending a filename will yield the path to that file in the"]
    #[doc = "bundle."]
    #[doc = ""]
    #[doc = "@param features A NULL terminated array of LV2_Feature structs which"]
    #[doc = "represent the features the host supports. Plugins may refuse to"]
    #[doc = "instantiate if required features are not found here. However, hosts MUST"]
    #[doc = "NOT use this as a discovery mechanism: instead, use the RDF data to"]
    #[doc = "determine which features are required and do not attempt to instantiate"]
    #[doc = "unsupported plugins at all. This parameter MUST NOT be NULL, i.e. a host"]
    #[doc = "that supports no features MUST pass a single element array containing"]
    #[doc = "NULL."]
    #[doc = ""]
    #[doc = "@return A handle for the new plugin instance, or NULL if instantiation"]
    #[doc = "has failed."]
    pub instantiate: ::std::option::Option<
        unsafe extern "C" fn(
            descriptor: *const _LV2_Descriptor,
            sample_rate: f64,
            bundle_path: *const ::std::os::raw::c_char,
            features: *const *const LV2_Feature,
        ) -> LV2_Handle,
    >,
    #[doc = "Connect a port on a plugin instance to a memory location."]
    #[doc = ""]
    #[doc = "Plugin writers should be aware that the host may elect to use the same"]
    #[doc = "buffer for more than one port and even use the same buffer for both"]
    #[doc = "input and output (see lv2:inPlaceBroken in lv2.ttl)."]
    #[doc = ""]
    #[doc = "If the plugin has the feature lv2:hardRTCapable then there are various"]
    #[doc = "things that the plugin MUST NOT do within the connect_port() function;"]
    #[doc = "see lv2core.ttl for details."]
    #[doc = ""]
    #[doc = "connect_port() MUST be called at least once for each port before run()"]
    #[doc = "is called, unless that port is lv2:connectionOptional. The plugin must"]
    #[doc = "pay careful attention to the block size passed to run() since the block"]
    #[doc = "allocated may only just be large enough to contain the data, and is not"]
    #[doc = "guaranteed to remain constant between run() calls."]
    #[doc = ""]
    #[doc = "connect_port() may be called more than once for a plugin instance to"]
    #[doc = "allow the host to change the buffers that the plugin is reading or"]
    #[doc = "writing. These calls may be made before or after activate() or"]
    #[doc = "deactivate() calls."]
    #[doc = ""]
    #[doc = "@param instance Plugin instance containing the port."]
    #[doc = ""]
    #[doc = "@param port Index of the port to connect. The host MUST NOT try to"]
    #[doc = "connect a port index that is not defined in the plugin\'s RDF data. If"]
    #[doc = "it does, the plugin\'s behaviour is undefined (a crash is likely)."]
    #[doc = ""]
    #[doc = "@param data_location Pointer to data of the type defined by the port"]
    #[doc = "type in the plugin\'s RDF data (e.g. an array of float for an"]
    #[doc = "lv2:AudioPort). This pointer must be stored by the plugin instance and"]
    #[doc = "used to read/write data when run() is called. Data present at the time"]
    #[doc = "of the connect_port() call MUST NOT be considered meaningful."]
    pub connect_port: ::std::option::Option<
        unsafe extern "C" fn(
            instance: LV2_Handle,
            port: u32,
            data_location: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = "Initialise a plugin instance and activate it for use."]
    #[doc = ""]
    #[doc = "This is separated from instantiate() to aid real-time support and so"]
    #[doc = "that hosts can reinitialise a plugin instance by calling deactivate()"]
    #[doc = "and then activate(). In this case the plugin instance MUST reset all"]
    #[doc = "state information dependent on the history of the plugin instance except"]
    #[doc = "for any data locations provided by connect_port(). If there is nothing"]
    #[doc = "for activate() to do then this field may be NULL."]
    #[doc = ""]
    #[doc = "When present, hosts MUST call this function once before run() is called"]
    #[doc = "for the first time. This call SHOULD be made as close to the run() call"]
    #[doc = "as possible and indicates to real-time plugins that they are now live,"]
    #[doc = "however plugins MUST NOT rely on a prompt call to run() after"]
    #[doc = "activate()."]
    #[doc = ""]
    #[doc = "The host MUST NOT call activate() again until deactivate() has been"]
    #[doc = "called first. If a host calls activate(), it MUST call deactivate() at"]
    #[doc = "some point in the future. Note that connect_port() may be called before"]
    #[doc = "or after activate()."]
    pub activate: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle)>,
    #[doc = "Run a plugin instance for a block."]
    #[doc = ""]
    #[doc = "Note that if an activate() function exists then it must be called before"]
    #[doc = "run(). If deactivate() is called for a plugin instance then run() may"]
    #[doc = "not be called until activate() has been called again."]
    #[doc = ""]
    #[doc = "If the plugin has the feature lv2:hardRTCapable then there are various"]
    #[doc = "things that the plugin MUST NOT do within the run() function (see"]
    #[doc = "lv2core.ttl for details)."]
    #[doc = ""]
    #[doc = "As a special case, when `sample_count` is 0, the plugin should update"]
    #[doc = "any output ports that represent a single instant in time (e.g. control"]
    #[doc = "ports, but not audio ports). This is particularly useful for latent"]
    #[doc = "plugins, which should update their latency output port so hosts can"]
    #[doc = "pre-roll plugins to compute latency. Plugins MUST NOT crash when"]
    #[doc = "`sample_count` is 0."]
    #[doc = ""]
    #[doc = "@param instance Instance to be run."]
    #[doc = ""]
    #[doc = "@param sample_count The block size (in samples) for which the plugin"]
    #[doc = "instance must run."]
    pub run: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle, sample_count: u32)>,
    #[doc = "Deactivate a plugin instance (counterpart to activate())."]
    #[doc = ""]
    #[doc = "Hosts MUST deactivate all activated instances after they have been run()"]
    #[doc = "for the last time. This call SHOULD be made as close to the last run()"]
    #[doc = "call as possible and indicates to real-time plugins that they are no"]
    #[doc = "longer live, however plugins MUST NOT rely on prompt deactivation. If"]
    #[doc = "there is nothing for deactivate() to do then this field may be NULL"]
    #[doc = ""]
    #[doc = "Deactivation is not similar to pausing since the plugin instance will be"]
    #[doc = "reinitialised by activate(). However, deactivate() itself MUST NOT fully"]
    #[doc = "reset plugin state. For example, the host may deactivate a plugin, then"]
    #[doc = "store its state (using some extension to do so)."]
    #[doc = ""]
    #[doc = "Hosts MUST NOT call deactivate() unless activate() was previously"]
    #[doc = "called. Note that connect_port() may be called before or after"]
    #[doc = "deactivate()."]
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle)>,
    #[doc = "Clean up a plugin instance (counterpart to instantiate())."]
    #[doc = ""]
    #[doc = "Once an instance of a plugin has been finished with it must be deleted"]
    #[doc = "using this function. The instance handle passed ceases to be valid after"]
    #[doc = "this call."]
    #[doc = ""]
    #[doc = "If activate() was called for a plugin instance then a corresponding call"]
    #[doc = "to deactivate() MUST be made before cleanup() is called. Hosts MUST NOT"]
    #[doc = "call cleanup() unless instantiate() was previously called."]
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle)>,
    #[doc = "Return additional plugin data defined by some extenion."]
    #[doc = ""]
    #[doc = "A typical use of this facility is to return a struct containing function"]
    #[doc = "pointers to extend the LV2_Descriptor API."]
    #[doc = ""]
    #[doc = "The actual type and meaning of the returned object MUST be specified"]
    #[doc = "precisely by the extension. This function MUST return NULL for any"]
    #[doc = "unsupported URI. If a plugin does not support any extension data, this"]
    #[doc = "field may be NULL."]
    #[doc = ""]
    #[doc = "The host is never responsible for freeing the returned value."]
    pub extension_data: ::std::option::Option<
        unsafe extern "C" fn(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout__LV2_Descriptor() {
    assert_eq!(
        ::std::mem::size_of::<_LV2_Descriptor>(),
        64usize,
        concat!("Size of: ", stringify!(_LV2_Descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<_LV2_Descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(_LV2_Descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).URI as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(URI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).instantiate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(instantiate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).connect_port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(connect_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).activate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).run as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).deactivate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(deactivate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).cleanup as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LV2_Descriptor>())).extension_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_LV2_Descriptor),
            "::",
            stringify!(extension_data)
        )
    );
}
pub type LV2_Descriptor = _LV2_Descriptor;
#[doc = "Type of the lv2_descriptor() function in a library (old discovery API)."]
pub type LV2_Descriptor_Function =
    ::std::option::Option<unsafe extern "C" fn(index: u32) -> *const LV2_Descriptor>;
#[doc = "Handle for a library descriptor."]
pub type LV2_Lib_Handle = *mut ::std::os::raw::c_void;
#[doc = "Descriptor for a plugin library."]
#[doc = ""]
#[doc = "To access a plugin library, the host creates an LV2_Lib_Descriptor via the"]
#[doc = "lv2_lib_descriptor() function in the shared object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LV2_Lib_Descriptor {
    #[doc = "Opaque library data which must be passed as the first parameter to all"]
    #[doc = "the methods of this struct."]
    pub handle: LV2_Lib_Handle,
    #[doc = "The total size of this struct.  This allows for this struct to be"]
    #[doc = "expanded in the future if necessary.  This MUST be set by the library to"]
    #[doc = "sizeof(LV2_Lib_Descriptor).  The host MUST NOT access any fields of this"]
    #[doc = "struct beyond get_plugin() unless this field indicates they are present."]
    pub size: u32,
    #[doc = "Destroy this library descriptor and free all related resources."]
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(handle: LV2_Lib_Handle)>,
    #[doc = "Plugin accessor."]
    #[doc = ""]
    #[doc = "Plugins are accessed by index using values from 0 upwards.  Out of range"]
    #[doc = "indices MUST result in this function returning NULL, so the host can"]
    #[doc = "enumerate plugins by increasing `index` until NULL is returned."]
    pub get_plugin: ::std::option::Option<
        unsafe extern "C" fn(handle: LV2_Lib_Handle, index: u32) -> *const LV2_Descriptor,
    >,
}
#[test]
fn bindgen_test_layout_LV2_Lib_Descriptor() {
    assert_eq!(
        ::std::mem::size_of::<LV2_Lib_Descriptor>(),
        32usize,
        concat!("Size of: ", stringify!(LV2_Lib_Descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<LV2_Lib_Descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(LV2_Lib_Descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LV2_Lib_Descriptor>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LV2_Lib_Descriptor),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LV2_Lib_Descriptor>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LV2_Lib_Descriptor),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LV2_Lib_Descriptor>())).cleanup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LV2_Lib_Descriptor),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LV2_Lib_Descriptor>())).get_plugin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LV2_Lib_Descriptor),
            "::",
            stringify!(get_plugin)
        )
    );
}
#[doc = "Type of the lv2_lib_descriptor() function in an LV2 library."]
pub type LV2_Lib_Descriptor_Function = ::std::option::Option<
    unsafe extern "C" fn(
        bundle_path: *const ::std::os::raw::c_char,
        features: *const *const LV2_Feature,
    ) -> *const LV2_Lib_Descriptor,
>;
