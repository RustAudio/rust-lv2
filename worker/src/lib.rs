use lv2_core::extension::ExtensionDescriptor;
use lv2_core::feature::*;
use lv2_core::plugin::{Plugin, PluginInstance};
use lv2_core::prelude::*;
use lv2_sys;
use std::marker::PhantomData;
use std::mem;
use std::os::raw::*; //get all common c_type

/// Host feature to schedule a worker call.
#[repr(transparent)]
pub struct Schedule<'a> {
    internal: &'a lv2_sys::LV2_Worker_Schedule,
}

impl<'a> Schedule<'a> {
    /// Request the host to call the worker thread.
    ///
    /// This function should be called from `run()` to request that the host call the `work()`
    /// method in a non-realtime context with the given arguments.
    ///
    /// This function is always safe to call from `run()`, but it is not guaranteed that the worker
    /// is actually called from a different thread. In particular, when free-wheeling (e.g. for
    /// offline rendering), the worker may be executed immediately. This allows single-threaded
    /// processing with sample accuracy and avoids timing problems when `run()` is executing much
    /// faster or slower than real-time.
    ///
    /// Plugins SHOULD be written in such a way that if the worker runs immediately, and responses
    /// from the worker are delivered immediately, the effect of the work takes place immediately
    /// with sample accuracy.
    pub fn schedule_work<P: Worker>(&self, worker_data: &P::WorkData) -> Result<(), WorkerError> {
        unsafe {
            let size = mem::size_of_val(worker_data) as u32;
            let ptr = worker_data as *const P::WorkData as *const c_void;
            let schedule_work = if let Some(schedule_work) = self.internal.schedule_work {
                schedule_work
            } else {
                return Err(WorkerError::Unknown);
            };
            match (schedule_work)(self.internal.handle, size, ptr) {
                lv2_sys::LV2_Worker_Status_LV2_WORKER_SUCCESS => Ok(()),
                lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN => Err(WorkerError::Unknown),
                lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_NO_SPACE => Err(WorkerError::NoSpace),
                _ => Err(WorkerError::Unknown),
            }
        }
    }
}

//lying on sync and send
unsafe impl Sync for Schedule<'_> {}
unsafe impl Send for Schedule<'_> {}

unsafe impl<'a> UriBound for Schedule<'a> {
    const URI: &'static [u8] = lv2_sys::LV2_WORKER__schedule;
}

unsafe impl<'a> Feature for Schedule<'a> {
    unsafe fn from_feature_ptr(feature: *const c_void) -> Option<Self> {
        (feature as *const lv2_sys::LV2_Worker_Schedule)
            .as_ref()
            .map(|internal| Self { internal })
    }
}

/// Response handler to use inside worker function when youwant to send response to `run()`.
pub struct ResponseHandler {
    /// function provided by the host to send response to `run()`
    response_function: lv2_sys::LV2_Worker_Respond_Function,
    /// Response handler provided by the host, must be passed to the host provided
    /// response_function.
    respond_handle: lv2_sys::LV2_Worker_Respond_Handle,
}

impl ResponseHandler {
    pub fn respond<P: Worker>(&self, response_data: &P::ResponseData) -> Result<(), WorkerError> {
        unsafe {
            let size = mem::size_of_val(response_data) as u32;
            let ptr = response_data as *const P::ResponseData as *const c_void;
            let response_function = if let Some(response_function) = self.response_function {
                response_function
            } else {
                return Err(WorkerError::Unknown);
            };
            match (response_function)(self.respond_handle, size, ptr) {
                lv2_sys::LV2_Worker_Status_LV2_WORKER_SUCCESS => Ok(()),
                lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN => Err(WorkerError::Unknown),
                lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_NO_SPACE => Err(WorkerError::NoSpace),
                _ => Err(WorkerError::Unknown),
            }
        }
    }
}

/// Errors potentially generated by worker methods
pub enum WorkerError {
    /// Unknown or general error
    Unknown,
    /// Failure due to a lack of space
    NoSpace,
}

/// Trait to provide worker extension to LV2 plugins.
///
/// The worker extension allows plugins to schedule work that must be performed in another thread.
/// Plugins can use this interface to safely perform work that is not real-time safe, and receive
/// the result in the run context. The details of threading are managed by the host, allowing
/// plugins to be simple and portable while using resources more efficiently.

/// Host feature allowing plugins to schedule work that must be performed in another thread.
/// Plugins can use this interface to safely perform work that is not real-time safe, and receive
/// the result in the run context.
pub trait Worker: Plugin {
    /// Data sended to the worker thread
    type WorkData;
    /// Data sended by the worker thread to `work_response`
    type ResponseData;
    /// The work to do in a non-real-time thread. The spec require plugins to implment this method.
    ///
    /// This is called by the host in a non-realtime context as requested, possibly with an
    /// arbitrary message to handle.
    ///
    /// A response can be sent to run() using respond. The plugin MUST NOT make any assumptions
    /// about which thread calls this method, except that there are no real-time requirements and
    /// only one call may be executed at a time. That is, the host MAY call this method from any
    /// non-real-time thread, but MUST NOT make concurrent calls to this method from several
    /// threads.
    fn work(
        &mut self,
        response_handler: &ResponseHandler,
        data: &Self::WorkData,
    ) -> Result<(), WorkerError>;

    /// Handle a response from the worker. The spec require plugins to implement this method even if
    /// many host support to not have it.
    ///
    /// This is called by the host in the run() context when a response from the worker is ready.
    fn work_response(&mut self, data: &Self::ResponseData) -> Result<(), WorkerError>;

    ///Called when all responses for this cycle have been delivered. (optional)
    ///
    ///Since work_response() may be called after run() finished, this provides a hook for code that
    ///must run after the cycle is completed.
    fn end_run(&mut self) -> Result<(), WorkerError> {
        Ok(())
    }
}

// A descriptor for the plugin. This is just a marker type to associate constants and methods with.
pub struct WorkerDescriptor<P: Worker> {
    plugin: PhantomData<P>,
}

unsafe impl<P: Worker> UriBound for WorkerDescriptor<P> {
    const URI: &'static [u8] = lv2_sys::LV2_WORKER__interface;
}

impl<P: Worker> WorkerDescriptor<P> {
    /// Extern unsafe version of `work` method actually called by the host
    unsafe extern "C" fn extern_work(
        handle: lv2_sys::LV2_Handle,
        response_function: lv2_sys::LV2_Worker_Respond_Function,
        respond_handle: lv2_sys::LV2_Worker_Respond_Handle,
        size: u32,
        data: *const c_void,
    ) -> lv2_sys::LV2_Worker_Status {
        //deref plugin_instance and get the plugin
        let plugin_instance =
            if let Some(plugin_instance) = (handle as *mut PluginInstance<P>).as_mut() {
                plugin_instance
            } else {
                return lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN;
            };
        let plugin = plugin_instance.instance_mut();
        //build response handler
        let response_handler = ResponseHandler {
            response_function,
            respond_handle,
        };
        //build ref to worker data from raw pointer
        let worker_data =
            if let Some(worker_data) = (data as *const <P as Worker>::WorkData).as_ref() {
                worker_data
            } else {
                return lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN;
            };
        if size as usize != mem::size_of_val(worker_data) {
            return lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN;
        }
        match plugin.work(&response_handler, worker_data) {
            Ok(()) => lv2_sys::LV2_Worker_Status_LV2_WORKER_SUCCESS,
            Err(WorkerError::Unknown) => lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN,
            Err(WorkerError::NoSpace) => lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_NO_SPACE,
        }
    }

    /// Extern unsafe version of `work_response` method actually called by the host
    unsafe extern "C" fn extern_work_response(
        handle: lv2_sys::LV2_Handle,
        size: u32,
        body: *const c_void,
    ) -> lv2_sys::LV2_Worker_Status {
        //deref plugin_instance and get the plugin
        let plugin_instance =
            if let Some(plugin_instance) = (handle as *mut PluginInstance<P>).as_mut() {
                plugin_instance
            } else {
                return lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN;
            };
        let plugin = plugin_instance.instance_mut();
        //build ref to response data from raw pointer
        let response_data =
            if let Some(response_data) = (body as *const <P as Worker>::ResponseData).as_ref() {
                response_data
            } else {
                return lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN;
            };
        if size as usize != mem::size_of_val(response_data) {
            return lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN;
        }

        match plugin.work_response(response_data) {
            Ok(()) => lv2_sys::LV2_Worker_Status_LV2_WORKER_SUCCESS,
            Err(WorkerError::Unknown) => lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN,
            Err(WorkerError::NoSpace) => lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_NO_SPACE,
        }
    }

    /// Extern unsafe version of `end_run` method actually called by the host
    // This throw a warning if it's not in `INTERFACE`
    unsafe extern "C" fn extern_end_run(handle: lv2_sys::LV2_Handle) -> lv2_sys::LV2_Worker_Status {
        if let Some(plugin_instance) = (handle as *mut PluginInstance<P>).as_mut() {
            let plugin = plugin_instance.instance_mut();
            match plugin.end_run() {
                Ok(()) => lv2_sys::LV2_Worker_Status_LV2_WORKER_SUCCESS,
                Err(WorkerError::Unknown) => lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN,
                Err(WorkerError::NoSpace) => lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_NO_SPACE,
            }
        } else {
            lv2_sys::LV2_Worker_Status_LV2_WORKER_ERR_UNKNOWN
        }
    }
}

// Implementing the trait that contains the interface.
impl<P: Worker> ExtensionDescriptor for WorkerDescriptor<P> {
    type ExtensionInterface = lv2_sys::LV2_Worker_Interface;

    const INTERFACE: &'static lv2_sys::LV2_Worker_Interface = &lv2_sys::LV2_Worker_Interface {
        work: Some(Self::extern_work),
        work_response: Some(Self::extern_work_response),
        //i want to have `None` here when the plugin doesn't implements the `end_run` trait method
        end_run: Some(Self::extern_end_run),
    };
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
